#!/usr/bin/env escript
%% -*- erlang -*-
%%! +Bd -noshell -smp auto

%%   Copyright 2022-2023 Mikael Pettersson
%%
%%   Licensed under the Apache License, Version 2.0 (the "License");
%%   you may not use this file except in compliance with the License.
%%   You may obtain a copy of the License at
%%
%%       http://www.apache.org/licenses/LICENSE-2.0
%%
%%   Unless required by applicable law or agreed to in writing, software
%%   distributed under the License is distributed on an "AS IS" BASIS,
%%   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%%   See the License for the specific language governing permissions and
%%   limitations under the License.
%%
%% gen_es_uc_ctype.escript
%%
%% Generate es_uc_ctype.erl from UnicodeData.txt
%%
%% Scheme has the following main character types (ctypes):
%%
%% - initial: letters and other characters that may start a symbol
%% - subsequent: decimal digits and other characters that may follow
%%   the initial character in a symbol
%% - whitespace: spaces, tabs, newlines, and similar
%% - delimiter: characters like left and right parenthesis, semicolon,
%%   and whitespace that always delimit other tokens
%% - digit: the decimal digits 0 to 9
%%
%% The first three ctypes are extended from ASCII to Unicode via the
%% general category of each Unicode code point.  The last two ctypes
%% only contain ASCII code points.
%%
%% We already have es_ctype.erl with hand-crafted tables and code for
%% ASCII ctypes.  Therefore this module only caters for extending the
%% first three ctypes to Unicode except ASCII (code points > 127).
%%
%% Subsequent includes initial, and is disjoint from whitespace.  Therefore
%% these ctypes can be treated as mutually exclusive (to check for subsequent
%% also check for initial), so there are only four possibilities per code
%% point (these three, and none), which fits in two bits.  Hence we pack
%% four ctypes in each byte in the Unicode lookup table.

-define(IS_NONE,       0).
-define(IS_WHITESPACE, 1).
-define(IS_SUBSEQUENT, 2). % check for >= 2 to include initial
-define(IS_INITIAL,    3).

-mode(compile).

-record(udata, {code :: non_neg_integer(), gc :: atom()}).

main([InFile, OutFile]) ->
  UnicodeData = read_unicode_data(InFile),
  UnicodeCtype = make_unicode_ctype(UnicodeData),
  write_ctype_module(UnicodeCtype, OutFile).

%% Write Ctype -----------------------------------------------------------------
%%
%% Convert the ctype array to a module with access functions and a lookup table.

write_ctype_module(UnicodeCtype, OutFile) ->
  {ok, IoDev} = file:open(OutFile, [write]),
  try
     do_write_ctype_module(UnicodeCtype, IoDev)
  after
    file:close(IoDev)
  end.

do_write_ctype_module(UnicodeCtype, IoDev) ->
  io:format(IoDev, "%% -*- erlang-indent-level: 2 -*-\n", []),
  io:format(IoDev, "%%\n", []),
  io:format(IoDev, "%%   Copyright 2022-2023 Mikael Pettersson\n", []),
  io:format(IoDev, "%%\n", []),
  io:format(IoDev, "%%   Licensed under the Apache License, Version 2.0 (the \"License\");\n", []),
  io:format(IoDev, "%%   you may not use this file except in compliance with the License.\n", []),
  io:format(IoDev, "%%   You may obtain a copy of the License at\n", []),
  io:format(IoDev, "%%\n", []),
  io:format(IoDev, "%%       http://www.apache.org/licenses/LICENSE-2.0\n", []),
  io:format(IoDev, "%%\n", []),
  io:format(IoDev, "%%   Unless required by applicable law or agreed to in writing, software\n", []),
  io:format(IoDev, "%%   distributed under the License is distributed on an \"AS IS\" BASIS,\n", []),
  io:format(IoDev, "%%   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", []),
  io:format(IoDev, "%%   See the License for the specific language governing permissions and\n", []),
  io:format(IoDev, "%%   limitations under the License.\n", []),
  io:format(IoDev, "%%\n", []),
  io:format(IoDev, "%% es_uc_ctype.erl\n", []),
  io:format(IoDev, "%%\n", []),
  io:format(IoDev, "%% Unicode character classification for ErlScheme.\n", []),
  io:format(IoDev, "%%\n", []),
  io:format(IoDev, "%% This file was generated by gen_es_uc_ctype.escript -- DO NOT EDIT.\n", []),
  io:format(IoDev, "\n", []),
  io:format(IoDev, "-module(es_uc_ctype).\n", []),
  io:format(IoDev, "\n", []),
  io:format(IoDev, "-export([is_initial/1, is_subsequent/1, is_whitespace/1]).\n", []),
  io:format(IoDev, "\n", []),
  io:format(IoDev, "-compile({inline, [{unicode_tab, 1}, {unicode_tab, 0}]}).\n", []),
  io:format(IoDev, "\n", []),
  io:format(IoDev, "-spec is_initial(char()) -> boolean().\n", []),
  io:format(IoDev, "is_initial(Ch) -> unicode_tab(Ch) =:= ~p.\n", [?IS_INITIAL]),
  io:format(IoDev, "\n", []),
  io:format(IoDev, "-spec is_subsequent(char()) -> boolean().\n", []),
  io:format(IoDev, "is_subsequent(Ch) -> unicode_tab(Ch) >= ~p.\n", [?IS_SUBSEQUENT]),
  io:format(IoDev, "\n", []),
  io:format(IoDev, "-spec is_whitespace(char()) -> boolean().\n", []),
  io:format(IoDev, "is_whitespace(Ch) -> unicode_tab(Ch) =:= ~p.\n", [?IS_WHITESPACE]),
  io:format(IoDev, "\n", []),
  io:format(IoDev, "-spec unicode_tab(char()) -> 0..3.\n", []),
  io:format(IoDev, "unicode_tab(Ch) ->\n", []),
  io:format(IoDev, "  Index = Ch bsr 2,\n", []), % Ch div 4
  io:format(IoDev, "  Offset = (Ch band 3) * 2,\n", []), % Ch rem 4
  io:format(IoDev, "  (binary:at(unicode_tab(), Index) bsr Offset) band 3.\n", []),
  io:format(IoDev, "\n", []),
  io:format(IoDev, "-spec unicode_tab() -> binary().\n", []),
  io:format(IoDev, "unicode_tab() ->\n", []),
  io:format(IoDev, "  <<\"", []),
  write_byte_array(UnicodeCtype, IoDev),
  io:format(IoDev, "\">>.\n", []).

write_byte_array(Array, IoDev) ->
  write_byte_array(0, array:size(Array), Array, IoDev).

write_byte_array(I, Size, Array, IoDev) when I < Size ->
  case I band 15 of
    0 -> io:format(IoDev, "\"\n  \"", []);
    _ -> ok
  end,
  write_hex_byte(IoDev, array:get(I, Array)),
  write_byte_array(I + 1, Size, Array, IoDev);
write_byte_array(I, Size, _Array, _IoDev) when I >= Size -> ok.

write_hex_byte(IoDev, Byte) ->
  io:format(IoDev, "\\x~2.16.0b", [Byte]).

%% Convert Unicode Data to Ctype -----------------------------------------------

make_unicode_ctype(UData) ->
  lists:foldl(fun record_ctype/2, array:new({default, 0}), UData).

record_ctype(#udata{code = Code} = UData, Arr) ->
  case udata_ctype(UData) of
    ?IS_NONE ->
      Arr;
    Ctype when (Ctype band bnot 3) =:= 0 ->
      Index = Code bsr 2, % div 4
      Offset = (Code band 3) * 2, % rem 4
      Byte = array:get(Index, Arr),
      0 = (Byte bsr Offset) band 3, % assert
      NewByte = Byte bor (Ctype bsl Offset),
      array:set(Index, NewByte, Arr)
  end.

udata_ctype(#udata{code = Code, gc = GC}) ->
  case Code of
    16#200C -> ?IS_INITIAL; % from R7RS, not in R6RS
    16#200D -> ?IS_INITIAL; % from R7RS, not in R6RS
    %% TODO: R6RS compat: U+0085 <next line> needs lexer adjustments
    _ ->
      if Code < 128 -> ?IS_NONE; % covered by existing ASCII table+logic
         true -> gc_ctype(GC)
      end
  end.

gc_ctype(GC) ->
  case GC of
    'Lu' -> ?IS_INITIAL;
    'Ll' -> ?IS_INITIAL;
    'Lt' -> ?IS_INITIAL;
    'Lm' -> ?IS_INITIAL;
    'Lo' -> ?IS_INITIAL;
    'Mn' -> ?IS_INITIAL;
    'Mc' -> ?IS_SUBSEQUENT;
    'Me' -> ?IS_SUBSEQUENT;
    'Nd' -> ?IS_SUBSEQUENT;
    'Nl' -> ?IS_INITIAL;
    'No' -> ?IS_INITIAL;
    'Pd' -> ?IS_INITIAL;
    'Pc' -> ?IS_INITIAL;
    'Po' -> ?IS_INITIAL;
    'Sc' -> ?IS_INITIAL;
    'Sm' -> ?IS_INITIAL;
    'Sk' -> ?IS_INITIAL;
    'So' -> ?IS_INITIAL;
    'Co' -> ?IS_INITIAL;
    %% The whitespace extensions are from R6RS, R7RS does not have them.
    'Zs' -> ?IS_WHITESPACE;
    %% TODO: R6RS compat: Zl (U+2028) and Zp (U+2029) need lexer adjustments
    _    -> ?IS_NONE
  end.

%% Reading Unicode Data --------------------------------------------------------
%%
%% This reads a UnicodeData.txt file and produces a list of #udata entries
%% recording the general category for each code point.

read_unicode_data(InFile) ->
  {ok, IoDev} = file:open(InFile, [read, raw, read_ahead]),
  try
    fold_lines(fun parse_udata/2, [], IoDev)
  after
    file:close(IoDev)
  end.

parse_udata(Line, Acc) ->
  case parse_udata(Line) of
    false -> Acc;
    Data -> [Data | Acc]
  end.

parse_udata(Line0) ->
  case string:chomp(Line0) of
    "" -> false; % ignore empty lines
    "#" ++ _ -> false; % ignore comment lines
    Line ->
      [ Code
      , _Name
      , GeneralCategory
      , _CombiningClass
      , _BiDiCategory
      , _Decomposition
      , _
      , _
      , _NumericValue
      , _BiDiMirrored
      , _Alias
      | _] = string:split(Line, ";", all),
      #udata{code = hex_to_int(Code), gc = string_to_gc(GeneralCategory)}
  end.

hex_to_int(Str) ->
  list_to_integer(string:trim(Str), 16).

string_to_gc(Str) ->
  list_to_atom(string:trim(Str)).

fold_lines(Fun, Acc, IoDev) ->
  fold_lines(Fun, Acc, 1, IoDev).

fold_lines(Fun, Acc, LineNr, IoDev) ->
  case file:read_line(IoDev) of
    {ok, Line} ->
      NewAcc = step_line(Fun, Line, Acc, LineNr),
      fold_lines(Fun, NewAcc, LineNr + 1, IoDev);
    eof -> Acc
  end.

step_line(Fun, Line, Acc, LineNr) ->
  try Fun(Line, Acc)
  catch Class:Reason:Stack ->
    io:format(standard_error, "failed to parse line ~p: ~s\n~p:~p\n~p\n",
              [LineNr, Line, Class, Reason, Stack]),
    Acc
  end.
